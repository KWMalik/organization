Jordan DavisExercise: find the product of the odd elements of a list.Def prod_odds(L):	Result=1For x in L:If x % 2 !=0      Result=result*xElse:	PassReturn result.#Also note: if  in this case does not need an else. Under the “command oriented” model of programming if the else part would be “else do nothing” it can be ommited.Excersise: given a list of numbers, return the list that results from squaring every element.Def square_list(L):Result=[ ]For x in L:Result = result + [x**2]Return result.#There is a built in map function for built-in lists.Def square_list(L):Return map(lambda x: x**2,L)#Functions can change attributes.Def inc_x(p):p.x=p.x + 1 def new_inc_x(p):p=point(p.x + 1,p.y)	# to understand why “def_inc” works and “def new_inc” dosen’t we need a deeper understanding of how data is layed out in memory. There are two types of data: value data and reference data. Ints, Bools, and Floats are value data which does not take up a lot of space. Strings, Tuples, Lists, and Objects are reference data which take up lots of space.# X holds an address that tells us where to find “point.”# Lists are a series of value and reference data.# when a value is passed to a function, the function makes a local copy of the argument. Any updates to the copy made by the function are therefore not visible to the caller on completion of the function.# This explains why “new_inc,” doesn’t work.# In the working function “def inc” changes to the local copy are still not visible but changes to what the local copy points to are visible.