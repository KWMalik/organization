CSCI 1105 Midterm Solutions, Fall 2009
======================================

1) Two reasons to use constants:
   - they provide built-in documentation by giving the opportunity to give
     descriptive names to important values
   - they allow for easy updating of programs simply by changing the value of
     the constant
   - (other reasonable answers may also be acceptable)

2) 9

3) class Date:
      def __init__(self, year, month, day):
         self.y = year
         self.m = month
         self.d = day

   Date(2009, 10, 21)

4) def list_fn(L):
     # if L == Empty
        #  base case
     # else
        #  ... L.hd ... list_fn(L.tl) ...

5) def count_zeroes(L):
      if L == Empty:
         return 0
      elif L.hd == 0:
         return 1 + count_zeroes(L.tl)
      else:
         return count_zeroes(L.tl)

6) The recursion should be sum_nums(n-1), not sum_nums(n).  With the given
  formulation of the program, if we were to call sum_nums(1), it would expand
  to 1 + sum_nums(1), and then 1 + 1 + sum_nums(1), and so on, continuing to
  accumulate a series of "1+"'s at the front, until the program either hits
  the recursion limit or runs out of memory.  Either way, the program will
  eventually crash.

7) def lockstep_fn(L1, L2):
      # if L1 is empty (or L2 is empty)
          # base case
      # else
          # ... L1.hd ... L2.hd ... lockstep_fn(L1.tl, L2.tl) ...

8) def max_lists(L1, L2):
      if L1 == Empty:
         return Empty
      else:
         return List(max(L1.hd, L2.hd), max_lists(L1.tl. L2.tl))

9a) The given implementation of length_at_least looks at the entire list, when
  we should know after looking at the first k elements (if present) that the
  length of the list is or is not at least k.  Performance is particularly bad
  when the list is exceptionally long and k is small.  For example, if the
  list has 1000 elements and k = 1, we examine the entire 1000-element list,
  when it would suffice just to look for a first element.

9b) def length_at_least(k, L):
       if k == 0:
          return True
       elif L == Empty:  # relies on the fact that the k==0 test has failed
          return False
       else:
          return length_at_least(k-1, L.tl)

  This implementation decrements k each time it probes an element of the list,
  and stops when either the list is empty or k=0.  Hence, it never examines
  more than k elements of the list.  For the 1000-element list, k=1 example
  above, this function would answer True after looking only at the first
  element of the list.

